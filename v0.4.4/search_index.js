var documenterSearchIndex = {"docs":
[{"location":"interactmodels/#InteractModels","page":"InteractModels","title":"InteractModels","text":"","category":"section"},{"location":"interactmodels/","page":"InteractModels","title":"InteractModels","text":"Modules = [InteractModels]","category":"page"},{"location":"interactmodels/#InteractModels.InteractModels","page":"InteractModels","title":"InteractModels.InteractModels","text":"InteractModels\n\n(Image: Stable) (Image: Dev) (Image: CI) (Image: Coverage)\n\nInteractModels is a subpackage of ModelParameters.jl that provides an interactive web interface that can run in Atom, Jupyter notebooks, Electron apps or be served on the web. \n\nIt's separated out to avoid loading the web stack when it isn't needed.\n\n\n\n\n\n","category":"module"},{"location":"interactmodels/#InteractModels.InteractModel","page":"InteractModels","title":"InteractModels.InteractModel","text":"InteractModel(f, model)\n\nAn AbstractModel that generates its own Interact.jl interface. Each model Param has a slider generated for it to update the model. After any slider updates the user-defined function f is passed the updated model to generate a new output - anything that will display in a WebIO.jl node, like a Plots.jl plot\n\nAfter any slider changes, the parent model is updated, so that parent(model) will return it's latest state.\n\nArguments\n\nf: a function that take the model object as an argument, but with Param fields replaced with their values. Usually a do block.\nmodel: any object with Params objects in some fields.\n\nParam fields\n\nParam objects in the model need to include a range or bounds field to define the slider range - holding an AbsractRange or NTuple{2}, respectively.\n\nOptionally, the Params can also include:\n\nA label field to use instead of field names\nA desciption field to use in mouse hover text\n\nKeyword Arguments\n\ntitle: \"\" set a window title, if you need it.\nsubmodel: Nothing. Type or Union that will group sliders into labeled subsections.\nthrottle: 0.1. Slider throttle, in seconds. Adjust to improve performance.\nlayout: vbox. This can be any three-argument function that will combine title, output, and sliders (all WebIO nodes) into a combined WebIO node. You can use this method to do any additional layout you need.\n\nExample\n\nThis is a simple example where the model is a NamedTuple, adapted from an Interact.jl example. It will display in atoms plot pane:\n\nusing InteractModels, Interact, ColorSchemes, Colors\n\ncolor(i) = Colors.hex(colors[i%length(colors)+1])\ncolors = ColorSchemes.viridis\nwidth, height = 700, 300\nnsamples = 256\n\nmodel = (;\n    sample_step=Param(val=0.05, range=0.01:0.001:0.1, label=\"Sample step\"),\n    phase=Param(val=0.0, range=0:0.1:2pi, label=\"Phase\"),\n    radii=Param(val=20,range=0:0.1:60, label=\"Radus\")\n)\n\nui = InteractModel(model; submodel=Nothing, throttle=0.1) do m\n    cxs_unscaled = [i * m.sample_step + m.phase for i in 1:nsamples]\n    cys = sin.(cxs_unscaled) .* height/3 .+ height/2\n    cxs = cxs_unscaled .* width/4pi\n    c = (dom\"svg:circle[cx=$(cxs[i]), cy=$(cys[i]), r=$(m.radii), fill=#$(color(i))]\"()\n         for i in 1:nsamples)\n    return dom\"svg:svg[width=$width, height=$height]\"(c...)\nend\n\n\n\n\n\n","category":"type"},{"location":"interactmodels/#InteractModels.attach_sliders!-Tuple{Any, AbstractModel}","page":"InteractModels","title":"InteractModels.attach_sliders!","text":"attach_sliders!(f, model::AbstractModel; submodel=false, throttle=0.1)\nattach_sliders!(model::AbstractModel; submodel=false, throttle=0.1, f=identity)\n\nInternal method that may be useful for creating custom interfaces like InteractModel, without actually using InteracModel directly. This interface will be less stable than InteractModel.\n\nCreate sliders and attach them to the model so it will be updated when they are moved.\n\nArguments\n\nf: a function that accepts the model, stripped of Param wrappers, with a return value that sets the observable obs. Usually this converts it to a plot or other web output.\nmodel: a AbstractModel\n\nKeyword Arguments\n\nthrottle: 0.1 - sliders response time, in seconds.\nsubmodel: Nothing. Type or Union that will group sliders into labeled subsections.\nobs: An optional observable to be updated when sliders change\n\nReturns a vbox holding the slider widgets.\n\n\n\n\n\n","category":"method"},{"location":"#ModelParameters","page":"ModelParameters","title":"ModelParameters","text":"","category":"section"},{"location":"","page":"ModelParameters","title":"ModelParameters","text":"Modules = [ModelParameters, InteractModels]","category":"page"},{"location":"#Overview","page":"ModelParameters","title":"Overview","text":"","category":"section"},{"location":"","page":"ModelParameters","title":"ModelParameters","text":"Modules = [ModelParameters]\nOrder   = [:module]","category":"page"},{"location":"#ModelParameters.ModelParameters","page":"ModelParameters","title":"ModelParameters.ModelParameters","text":"ModelParameters\n\n(Image: Stable) (Image: Dev) (Image: CI) (Image: Coverage)\n\nModelParameters simplifies the process of writing and using complex, high performance models, decoupling technical decisions about model structure and composition from usability concerns. \n\nIt provides linear indexing of parameters, a Tables.jl interface, and controllable Interact.jl Interfaces (via InteractModels.jl) – for any object, of any complexity. Parameters of immutable objects can be updated from a vector, tuple or table using a single command, rebuilding the object with the new values.\n\nUse case\n\nModelParameters.jl is designed to help writing physics/environmental/ecological models with heterogeneous structure and multiple formulation options. \n\nOnce these models grow beyond a certain complexity it becomes preferable to organise them in modular way, and to reuse components in variants in other models. This pattern is seen in climate models and land models related to CLIMA project, and in ecological modelling tools like DynamicGrids.jl and GrowthMaps.jl that this package was built for.\n\nModels may be structured as a composed nested hierarchy of structs, Tuple chains of objects, NameTuples, or some combination of the above. For performance, or running on GPUs, immutability is often necessary.\n\nThe problem comes when trying to use these models in Optim.jl, or run sensitivity analysis on them with DiffEqSensitivity.jl, or pass priors to a Bayesian modelling package. These packages often need parameter values, bounds and priors as Vectors. They may also need to update the model with new parameters as required. Writing out these conversions for every model combination is error prone and inefficient - especially with nested immutable models, that need to be rebuilt to change the parameters.\n\nModelParameters.jl can convert any arbitrarily complex model built with structs, Tuples and NamedTuples into vectors of values, bounds, priors, and anything else you need to attach, and easily reconstruct the whole model when they are updated. This is facilitated by wrapping your parameters, wherever they are in the model, in a Param:\n\nusing ModelParameters\n\nBase.@kwdef struct Submodel1{A,B}\n    α::A = Param(0.8, bounds=(0.2, 0.9))\n    β::B = Param(0.5, bounds=(0.7, 0.4))\nend\n\nBase.@kwdef struct Submodel2{Γ}\n    γ::Γ = Param(1e-3, bounds=(1e-4, 1e-2))\nend\n\nBase.@kwdef struct SubModel3{Λ,X}\n    λ::Λ = Param(0.8, bounds=(0.2, 0.9))\n    x::X = Submodel2()\nend\n\njulia> model = Model((Submodel1(), SubModel3()))\nModel with parent object of type: \n\nTuple{Submodel1{Param{Float64,NamedTuple{(:val, :bounds),Tuple{Float64,Tuple{Float64,Float64}}}},Param{Float64,NamedTuple{(:val, :bounds),Tuple{Float64,Tuple{Float64,Float64}}}}},SubModel3{Param{Float64,NamedTuple{(:val, :bounds),Tuple{Float64,Tuple{Float64,Float64}}}},Submodel2{Param{Float64,NamedTuple{(:val, :bounds)\n,Tuple{Float64,Tuple{Float64,Float64}}}}}}}\n\nAnd parameters:\n┌───────────┬───────┬───────┬────────────────┐\n│ component │ field │   val │         bounds │\n├───────────┼───────┼───────┼────────────────┤\n│ Submodel1 │     α │   0.8 │     (0.2, 0.9) │\n│ Submodel1 │     β │   0.5 │     (0.7, 0.4) │\n│ SubModel3 │     λ │   0.8 │     (0.2, 0.9) │\n│ Submodel2 │     γ │ 0.001 │ (0.0001, 0.01) │\n└───────────┴───────┴───────┴────────────────┘\n\njulia> model[:val]\n(0.8, 0.5, 0.8, 0.001)\n\nTo get the model values as a vector for Optim.jl, simply:\n\ncollect(model[:val])\n\nWhat are Params?\n\nParam is a wrapper for your parameter value and any metadata you need to track about it. Param has flexible fields, but expects to always have a :val field – which is the default if you don't used a keyword argument:\n\npar = Param(99.0)\n@assert par.val == 99.0\n\nInternally Param uses a NamedTuple to be flexible for scripting. You can just add any fields you need. When parameters are built into a Model, they are standardised so that they all have the same fields, filling the gaps with nothing. \n\nThere are a few other \"privileged\" fields that have specific behaviour, if you use them. A units field will be combined other fields using withunits, and this is done by default for val when you run stripparams on the models - if there is actually a units field. The InteractModel in the sub-package InteractModels.jl may also combine range or bounds fields with units and use them to construct sliders.\n\nParam is also a Number, and should work as-is in a lot of models for convenience. But it can easily be stripped from objects using stripparams.\n\nWhat is a Model?\n\nA model is another wrapper type, this time for a whole model - whatever it may be. Its a mutable and untyped containers for you typed, immutable models, so they can be updated in a user interface or by using setproperties!. Letting you keep a handle to the updated version. Model gives you a Tables.jl interface, provides a table of parameters in the REPL, and give you some powerful tools for making changes to your model. \n\nThere is a more limited StaticModel variant where you need maximum performance and don't need a handle to the model object.\n\nAn InteractModel from the InteractModels.jl subpackage is identical to Model, with the addition of an Interact.jl interface. It accepts a function that generates anything that can go into a web page (like a plot) in response to model parameter changes you make with the generated sliders.\n\nSetting model values\n\nSetting new values\n\nYou can also add new columns to all model parameters directly from the model:\n\nmodel[:bounds] = ((1.0, 4.0), (0.0, 1.0), (0.0, 0.1), (0.0, 100.0))\n\nSwapping number types\n\nModelParameters makes it very easy to make modifications to your model parameters. To update all model values to be Float32, you can simply do: \n\nmodel[:val] = map(Float32, model[:val])\n\nTables.jl interface\n\nYou can also save and import your model parameters to/from CSV or any other kind of Table or DataFrame using the Tables.jl interface:\n\nupdate!(model, table)\n\nLive Interact.jl models\n\nInteractModels.jl is a subpackage of ModelParameters.jl, but needs to be installed separately. This avoids loading the heavy web-stack dependencies of Interact.jl when you don't need them.\n\nUsing InteractModels, any model can have an Interact.jl web interface defined for it automatically, by providing a function that plots or displays your model in some way that can show in a web page. The interface, slider controllers and model updates are all taken care of.\n\nPotential Problems\n\nIf you define structs with type parameters that are not connected to fields, ModelParameters.jl will not be able to reconstruct them with new Param values, or use stripparams to remove the Param wrappers.\n\nDefining ConstructionBase.constructorof from ConstructionBase.jl is the solution to this, and will also mean your objects can be used with other packages for immutable manipulation like Flatten.jl, Setfield.jl, Accessors.jl and BangBang.jl.\n\nConstructionBaseExtras.jl also exists to add support to common packages, such as StaticArrays.jl arrays. Import it if you  need StaticArrays support, or open an issue to add support to additional packages.\n\nNote: Breaking change in 0.4.0 With the introduction of weak extensions in Julia 1.9, ConstructionBase.jl and ConstructionBaseExtras.jl should not be loaded at the same time (see this issue).  ModelParameters.jl has dropped the direct dependency on ConstructionBase.jl in version 0.4.0. Users that employ Julia versions <1.9 are advised to load ConstructionBaseExtras.jl themselves if StaticArrays.jl  support is needed.\n\n\n\n\n\n","category":"module"},{"location":"#Types","page":"ModelParameters","title":"Types","text":"","category":"section"},{"location":"","page":"ModelParameters","title":"ModelParameters","text":"Modules = [ModelParameters]\nOrder   = [:type]","category":"page"},{"location":"#ModelParameters.AbstractModel","page":"ModelParameters","title":"ModelParameters.AbstractModel","text":"Abstract supertype for model wrappers like Model, useful if you need to extend the behaviour of this package.\n\nAccessing AbstactModel parameters\n\nFields can be accessed with getindex:\n\nmodel = Model(obj)\n@assert model[:val] isa Tuple\n@assert model[:val] == model[:val]\n@assert model[:units] == model[:units]\n\nTo get a combined Tuple of val and units, use withunits.\n\nThe type name of the parent model component, and the field name are also available:\n\nmodel[:component]\nmodel[:fieldname]\n\nGetting a Vector of parameter values\n\nBase methods collect, vec, and Array return a vector of the result of  model[:val]. To get a vector of other parameter fields, simply collect the tuple:\n\nboundsvec = collect(model[:bounds])\n\nTables.jl interface\n\nAll AbstractModels define the Tables.jl interface. This means their paremeters and parameter metadata can be converted to a DataFrame or CSV very easily:\n\ndf = DataFrame(model)\n\nTables.rows will also return all Params as a Vector of NamedTuple.\n\nTo update a model with params from a table, use update! or update:\n\nupdate!(model, table)\n\nAbstractModel Interface: Defining your own model wrappers\n\nIt may be simplest to use ModelParameters.jl on a wrapper type you also use for other  things. This is what DynamicGrids.jl does with Ruleset. It's straightforward to extend  the interface, nearly everything is taken care of by inheriting from AbstractModel. But  in some circumstances you will need to define additional methods.\n\nAbstractModel uses Base.parent to return the parent model object. Either use a field :parent on your <: AbstractModel type, or add a  method to Base.parent. \n\nWith a custom parent field you will also need to define a method for  setparent! and setparent that sets the correct field.\n\nAn AbstractModel with complicated type parameters may require a method of  ConstructionBase.constructorof.\n\nTo add custom show methods but still print the parameter table, you can use:\n\nprintparams(io::IO, model)\n\nThat should be all you need to do.\n\n\n\n\n\n","category":"type"},{"location":"#ModelParameters.AbstractParam","page":"ModelParameters","title":"ModelParameters.AbstractParam","text":"Abstract supertype for parameters. Theses are wrappers for model parameter values and  metadata that are returned from params, and used in  getfield/setfield/getpropery/setproperty methods and to generate the Tables.jl interface.  They are stripped from the model with stripparams.\n\nAn AllParams must define a Base.parent method that returns a NamedTuple, and a constructor that accepts a NamedTuple. It must have a val property, and should use checkhasval in its constructor.\n\n\n\n\n\n","category":"type"},{"location":"#ModelParameters.MakieModel","page":"ModelParameters","title":"ModelParameters.MakieModel","text":"MakieModel(f, model)\n\nAn AbstractModel that generates its own Makie.jl interface. Each model Param has a slider generated for it to update the model. Function f is passed a Makie.GridLayout to plot into and an Observables.Observable that holds the model object stripped of Params, with the values of the sliders in  the interface. After any slider updates the Observable is updated.\n\nFunction f only runs once, on initialisation. In it Makie.lift should be used on the model to create an Observable which can be plotted into one or many Makie.Axis created in the GridLayout.\n\nArguments\n\nf: a function that take a GridLayout and model object wrapped as an Observable as arguments.\nmodel: any object with Params objects in some fields.\n\nKeyword Arguments\n\ntitle: \"\" set a window title, if you need it.\nslider_kw: An optional NamedTuple of keywords to pass to all sliders.\nncolumns: Group sliders in n columns, 1 by default.\nfigure: An optional Makie Figure.\nlayout: An optional Makie GridLayout that gets passed to f\n\nParam fields\n\nParam objects in the model can include keywords:\n\nlabel: field to use instead of field names\nrange: an AbsractRange of slider positions\nbounds: an NTuple{2} for min and max of slider ranges,    if range is not available.\n\nWithouth range or bounds the range will be guessed from val.\n\nExample\n\nThis is a simple example where the model is a NamedTuple that changes the color patterns of \n\nusing ModelParameters, GLMakie, CSV\n\n# Define some parameters\nmodel = (; \n    noise=Param(0.5, bounds=(0.0, 1.0), label=\"Noise\"),\n    color=Param(0.5, bounds=(0.0, 1.0), label=\"Color\"),\n)\n\n# Define a function that generates a random array from our model `m`\nrandarray(m) = max.(min.((rand(10, 10) .- 0.5) .* m.noise .+ m.color, 1.0), 0.0)\n\n# Make an interactive model \nmm = MakieModel(model; ncolumns=2) do layout, model_obs\n    # `model_obs` is our model with `Params` stripped and wrapped as an `Observable`.\n    # We can `lift` it to run `f` and update a new \n    x = lift(randarray, model_obs)\n    # Define an axis to plot into\n    ax = Axis(layout[1, 1])\n    # And plot a heatmap of the output of `f`\n    heatmap!(ax, x; colorrange=(0, 1))\nend\n\n# We can save the parameters set in the interface\n# to anything Tables.jl compatible, like csv\nCSV.write(\"modelparams.csv\", mm)\n\n\n\n\n\n","category":"type"},{"location":"#ModelParameters.Model","page":"ModelParameters","title":"ModelParameters.Model","text":"Model(x)\n\nA wrapper type for any model containing Param parameters - essentially marking  that a custom struct or Tuple holds Param fields.\n\nThis allows you to index into the model as if it is a linear list of parameters, or named  columns of values and paramiter metadata. You can treat it as an iterable, or use the  Tables.jl interface to save or update the model to/from csv, a DataFrame or any source  that implements the Tables.jl interface.\n\n\n\n\n\n","category":"type"},{"location":"#ModelParameters.Param","page":"ModelParameters","title":"ModelParameters.Param","text":"Param(p::NamedTuple)\nParam(; kw...)\nParam(val)\n\nA wrapper type that lets you extract model parameters and metadata about the model like bounding val, units priors, or anything else you want to attach.\n\nThe first argument is assigned to the val field, and if only keyword arguments are used, val, must be one of them. val is used as the number val if the model us run without stripping out the Param fields. stripparams also takes only the :val field.\n\n\n\n\n\n","category":"type"},{"location":"#ModelParameters.RealParam","page":"ModelParameters","title":"ModelParameters.RealParam","text":"RealParam(p::NamedTuple)\nRealParam(; kw...)\nRealParam(val)\n\nA wrapper type that lets you extract Real typed model parameters and metadata  about the model like bounding val, units priors, or anything else you want to attach.\n\nThe first argument is assigned to the val field, and if only keyword arguments are used, val, must be one of them. val is used as the number val if the model us run without stripping out the Param fields. stripparams also takes only the :val field.\n\n\n\n\n\n","category":"type"},{"location":"#ModelParameters.StaticModel","page":"ModelParameters","title":"ModelParameters.StaticModel","text":"StaticModel(x)\n\nLike Model but immutable. This means it can't be used as a handle to add columns to your model or update it in a user interface.\n\n\n\n\n\n","category":"type"},{"location":"#Methods","page":"ModelParameters","title":"Methods","text":"","category":"section"},{"location":"","page":"ModelParameters","title":"ModelParameters","text":"Modules = [ModelParameters]\nOrder   = [:function]","category":"page"},{"location":"#ModelParameters.component-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"ModelParameters","title":"ModelParameters.component","text":"component(::Type{T}) where T\n\nGenerates the identifier stored in the :component field of an AbstractModel. The default implementation simply uses T.name.wrapper which is the UnionAll type corresponding to the unparameterized type name of T.\n\n\n\n\n\n","category":"method"},{"location":"#ModelParameters.groupparams-Tuple{AbstractModel}","page":"ModelParameters","title":"ModelParameters.groupparams","text":"groupparams(m::AbstractModel, cols::Symbol...)\n\nGroups parameters in m hierarchically according to cols. A Symbol constructor must be defined for the value type of each parameter field (e.g. String, Symbol, and Int would all be valid by default). The returned value is a nested named tuple where the hierachical order follows the order of cols.\n\nFor example, we could group parameters first by component name, then by field name:\n\nExamples\n\njulia> groupparams(Model((a=Param(1.0), b=Param(2.0))), :component, :fieldname)\n(NamedTuple = (a = ..., b = ...),)\n\n\n\n\n\n","category":"method"},{"location":"#ModelParameters.mapflat-Union{Tuple{T}, Tuple{Any, Any}} where T","page":"ModelParameters","title":"ModelParameters.mapflat","text":"mapflat(f, collection; maptype::Type=Union{NamedTuple,Tuple,AbstractArray})\n\n\"Flattened\" version of map where f is applied to all nested non-collection elements of x. The transformed result is returned with the nested structure of the input x unchanged. Note that this differs from flatmap in functional settings, which is typically just map followed by flatten.\n\nExamples\n\njulia> mapflat(x -> 2*x, (a = (b = (1,)), c = (d = (2,))))\n(a = (b = (2,)), c = (d = (4,)))\n\n\n\n\n\n","category":"method"},{"location":"#ModelParameters.params","page":"ModelParameters","title":"ModelParameters.params","text":"params(object)\nparams(model::AbstractModel)\n\nReturns a tuple of all Params in the model or arbitrary object.\n\n\n\n\n\n","category":"function"},{"location":"#ModelParameters.printparams","page":"ModelParameters","title":"ModelParameters.printparams","text":"printparams(object)\nprintparams(io::IO, object)\n\nPrints a table of all Params in the object, similar to what is printed in the repl for AbstractModel.\n\n\n\n\n\n","category":"function"},{"location":"#ModelParameters.setparent","page":"ModelParameters","title":"ModelParameters.setparent","text":"setparent(model::AbstractModel, x)\n\nInternal interface method to define for custom AbstractModel with a different field for parent.\n\nSet the parent object and return the rebuilt model. Must be defined  if the parent field of an AbstractModel is not :parent.\n\n\n\n\n\n","category":"function"},{"location":"#ModelParameters.setparent!","page":"ModelParameters","title":"ModelParameters.setparent!","text":"setparent!(model::MutableModel, x)\n\nInternal interface method to define for custom AbstractModel with a different field for parent.\n\nSet the parent object. Must be defined if the parent field of an AbstractModel is not :parent.\n\n\n\n\n\n","category":"function"},{"location":"#ModelParameters.stripparams","page":"ModelParameters","title":"ModelParameters.stripparams","text":"stripparams(object)\n\nStrips all AbstractParam from an object, replacing them with the val  field, or a combination of val and units if a units field exists.\n\n\n\n\n\n","category":"function"},{"location":"#ModelParameters.stripunits","page":"ModelParameters","title":"ModelParameters.stripunits","text":"stripunits(model::AbstractModel, xs)\nstripunits(param::AbstractParam, x)\n\nReturns the x or xs divided by their corresponding units field, if it exists.\n\nIt there is no units field, and x has units, it will be returned with units! It you want to simply remove all units, using Unitful.ustrip.\n\n\n\n\n\n","category":"function"},{"location":"#ModelParameters.update","page":"ModelParameters","title":"ModelParameters.update","text":"update(m::AbstractModel, table)\n\nUpdate the model from an object that implements the Tables.jl interface, returning a new, updated object.\n\n\n\n\n\n","category":"function"},{"location":"#ModelParameters.update!","page":"ModelParameters","title":"ModelParameters.update!","text":"update!(m::MutableModel, table)\n\nUpdate the model in-place from an object that implements the Tables.jl interface.\n\nNote: the parent object can be immutable, it will be completely rebuilt.  But the wrapper AbstractModel is mutable, such as Model or InteractModel.\n\n\n\n\n\n","category":"function"},{"location":"#ModelParameters.withunits","page":"ModelParameters","title":"ModelParameters.withunits","text":"withunits(object, [fieldname])\nwithunits(model::AbstractModel, [fieldname])\nwithunits(param::AbstractParam, [fieldname])\n\nReturns the field specifed by fieldname (by default :val) for a single Param,  or a tuple of the Params in a Model or arbitrary object. \n\nIf there is a units field the returned value will be a combination of the specied field  and the units fields. \n\nIf there is no units field or a specific Params units fields contains nothing,  the field value is returned unchanged.\n\n\n\n\n\n","category":"function"}]
}
